import _createClass from "@babel/runtime/helpers/esm/createClass";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _wrapNativeSuper from "@babel/runtime/helpers/esm/wrapNativeSuper";
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
/* eslint-disable no-use-before-define */
/**
 * Spacemesh API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2alpha1
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";
var BASE_PATH = "https://testnet-api.spacemesh.network".replace(/\/+$/, "");

/**
 *
 * @export
 */
export var COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|"
};

/**
 *
 * @export
 */

/**
 *
 * @export
 */

/**
 *
 * @export
 */

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export var RequiredError = /*#__PURE__*/function (_Error) {
  function RequiredError(field, msg) {
    var _this;
    _classCallCheck(this, RequiredError);
    _this = _callSuper(this, RequiredError, [msg]);
    _this.name = "RequiredError";
    return _this;
  }
  _inherits(RequiredError, _Error);
  return _createClass(RequiredError);
}( /*#__PURE__*/_wrapNativeSuper(Error));

/**
 * The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details.  You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
 * @export
 */

/**
 * 
 * @export
 * @enum {string}
 */

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }     // or ...     if (any.isSameTypeAs(Foo.getDefaultInstance())) {       foo = any.unpack(Foo.getDefaultInstance());     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".  JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 * @enum {string}
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * An immutable Spacemesh transaction. do not include mutable data such as tx state or result.
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 * @enum {string}
 */

/**
 * TransactionState is the \"journey\" of a tx from mempool to block inclusion to mesh to STF processing. To know whether or not the tx actually succeeded, and its side effects, check tx_state.   - TRANSACTION_STATE_UNSPECIFIED: default state  - TRANSACTION_STATE_REJECTED: rejected from mempool due to, e.g., invalid syntax  - TRANSACTION_STATE_INSUFFICIENT_FUNDS: rejected from mempool by funds check  - TRANSACTION_STATE_CONFLICTING: rejected from mempool due to conflicting counter  - TRANSACTION_STATE_MEMPOOL: in mempool but not on the mesh yet  - TRANSACTION_STATE_MESH: submitted to the mesh  - TRANSACTION_STATE_PROCESSED: processed by STF; check Receipt for success or failure
 * @export
 * @enum {string}
 */

/**
 * 
 * @export
 * @enum {string}
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 * @enum {string}
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * 
 * @export
 */

/**
 * AccountServiceApi - fetch parameter creator
 * @export
 */
export var AccountServiceApiFetchParamCreator = function AccountServiceApiFetchParamCreator(configuration) {
  return {
    /**
     * 
     * @throws {RequiredError}
     */
    accountServiceList: function accountServiceList(body, options) {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling accountServiceList.');
      }
      var localVarPath = "/spacemesh.v2alpha1.AccountService/List";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {};
      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof body !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body != null ? body : {}) : body || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
/**
 * AccountServiceApi - factory function to inject configuration 
 * @export
 */
export var AccountServiceApi = function AccountServiceApi(configuration) {
  var fetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : portableFetch;
  var basePath = configuration && configuration.basePath || BASE_PATH;
  return {
    /**
     * 
     * @throws {RequiredError}
     */
    accountServiceList: function accountServiceList(body) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localVarFetchArgs = AccountServiceApiFetchParamCreator(configuration).accountServiceList(body, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    }
  };
};

/**
 * ActivationServiceApi - fetch parameter creator
 * @export
 */
export var ActivationServiceApiFetchParamCreator = function ActivationServiceApiFetchParamCreator(configuration) {
  return {
    /**
     * 
     * @throws {RequiredError}
     */
    activationServiceActivationsCount: function activationServiceActivationsCount(body, options) {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling activationServiceActivationsCount.');
      }
      var localVarPath = "/spacemesh.v2alpha1.ActivationService/ActivationsCount";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {};
      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof body !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body != null ? body : {}) : body || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @throws {RequiredError}
     */
    activationServiceList: function activationServiceList(body, options) {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling activationServiceList.');
      }
      var localVarPath = "/spacemesh.v2alpha1.ActivationService/List";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {};
      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof body !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body != null ? body : {}) : body || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
/**
 * ActivationServiceApi - factory function to inject configuration 
 * @export
 */
export var ActivationServiceApi = function ActivationServiceApi(configuration) {
  var fetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : portableFetch;
  var basePath = configuration && configuration.basePath || BASE_PATH;
  return {
    /**
     * 
     * @throws {RequiredError}
     */
    activationServiceActivationsCount: function activationServiceActivationsCount(body) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localVarFetchArgs = ActivationServiceApiFetchParamCreator(configuration).activationServiceActivationsCount(body, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    },
    /**
     * 
     * @throws {RequiredError}
     */
    activationServiceList: function activationServiceList(body) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localVarFetchArgs = ActivationServiceApiFetchParamCreator(configuration).activationServiceList(body, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    }
  };
};

/**
 * LayerServiceApi - fetch parameter creator
 * @export
 */
export var LayerServiceApiFetchParamCreator = function LayerServiceApiFetchParamCreator(configuration) {
  return {
    /**
     * 
     * @throws {RequiredError}
     */
    layerServiceList: function layerServiceList(body, options) {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling layerServiceList.');
      }
      var localVarPath = "/spacemesh.v2alpha1.LayerService/List";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {};
      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof body !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body != null ? body : {}) : body || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
/**
 * LayerServiceApi - factory function to inject configuration 
 * @export
 */
export var LayerServiceApi = function LayerServiceApi(configuration) {
  var fetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : portableFetch;
  var basePath = configuration && configuration.basePath || BASE_PATH;
  return {
    /**
     * 
     * @throws {RequiredError}
     */
    layerServiceList: function layerServiceList(body) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localVarFetchArgs = LayerServiceApiFetchParamCreator(configuration).layerServiceList(body, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    }
  };
};

/**
 * NetworkServiceApi - fetch parameter creator
 * @export
 */
export var NetworkServiceApiFetchParamCreator = function NetworkServiceApiFetchParamCreator(configuration) {
  return {
    /**
     * 
     * @throws {RequiredError}
     */
    networkServiceInfo: function networkServiceInfo(body, options) {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling networkServiceInfo.');
      }
      var localVarPath = "/spacemesh.v2alpha1.NetworkService/Info";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {};
      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof body !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body != null ? body : {}) : body || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
/**
 * NetworkServiceApi - factory function to inject configuration 
 * @export
 */
export var NetworkServiceApi = function NetworkServiceApi(configuration) {
  var fetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : portableFetch;
  var basePath = configuration && configuration.basePath || BASE_PATH;
  return {
    /**
     * 
     * @throws {RequiredError}
     */
    networkServiceInfo: function networkServiceInfo(body) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localVarFetchArgs = NetworkServiceApiFetchParamCreator(configuration).networkServiceInfo(body, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    }
  };
};

/**
 * NodeServiceApi - fetch parameter creator
 * @export
 */
export var NodeServiceApiFetchParamCreator = function NodeServiceApiFetchParamCreator(configuration) {
  return {
    /**
     * 
     * @throws {RequiredError}
     */
    nodeServiceStatus: function nodeServiceStatus(body, options) {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling nodeServiceStatus.');
      }
      var localVarPath = "/spacemesh.v2alpha1.NodeService/Status";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {};
      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof body !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body != null ? body : {}) : body || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
/**
 * NodeServiceApi - factory function to inject configuration 
 * @export
 */
export var NodeServiceApi = function NodeServiceApi(configuration) {
  var fetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : portableFetch;
  var basePath = configuration && configuration.basePath || BASE_PATH;
  return {
    /**
     * 
     * @throws {RequiredError}
     */
    nodeServiceStatus: function nodeServiceStatus(body) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localVarFetchArgs = NodeServiceApiFetchParamCreator(configuration).nodeServiceStatus(body, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    }
  };
};

/**
 * RewardServiceApi - fetch parameter creator
 * @export
 */
export var RewardServiceApiFetchParamCreator = function RewardServiceApiFetchParamCreator(configuration) {
  return {
    /**
     * 
     * @throws {RequiredError}
     */
    rewardServiceList: function rewardServiceList(body, options) {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling rewardServiceList.');
      }
      var localVarPath = "/spacemesh.v2alpha1.RewardService/List";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {};
      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof body !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body != null ? body : {}) : body || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
/**
 * RewardServiceApi - factory function to inject configuration 
 * @export
 */
export var RewardServiceApi = function RewardServiceApi(configuration) {
  var fetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : portableFetch;
  var basePath = configuration && configuration.basePath || BASE_PATH;
  return {
    /**
     * 
     * @throws {RequiredError}
     */
    rewardServiceList: function rewardServiceList(body) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localVarFetchArgs = RewardServiceApiFetchParamCreator(configuration).rewardServiceList(body, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    }
  };
};

/**
 * TransactionServiceApi - fetch parameter creator
 * @export
 */
export var TransactionServiceApiFetchParamCreator = function TransactionServiceApiFetchParamCreator(configuration) {
  return {
    /**
     * 
     * @throws {RequiredError}
     */
    transactionServiceEstimateGas: function transactionServiceEstimateGas(body, options) {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling transactionServiceEstimateGas.');
      }
      var localVarPath = "/spacemesh.v2alpha1.TransactionService/EstimateGas";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {};
      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof body !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body != null ? body : {}) : body || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @throws {RequiredError}
     */
    transactionServiceList: function transactionServiceList(body, options) {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling transactionServiceList.');
      }
      var localVarPath = "/spacemesh.v2alpha1.TransactionService/List";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {};
      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof body !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body != null ? body : {}) : body || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @throws {RequiredError}
     */
    transactionServiceParseTransaction: function transactionServiceParseTransaction(body, options) {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling transactionServiceParseTransaction.');
      }
      var localVarPath = "/spacemesh.v2alpha1.TransactionService/ParseTransaction";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {};
      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof body !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body != null ? body : {}) : body || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @throws {RequiredError}
     */
    transactionServiceSubmitTransaction: function transactionServiceSubmitTransaction(body, options) {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling transactionServiceSubmitTransaction.');
      }
      var localVarPath = "/spacemesh.v2alpha1.TransactionService/SubmitTransaction";
      var localVarUrlObj = url.parse(localVarPath, true);
      var localVarRequestOptions = Object.assign({}, {
        method: 'POST'
      }, options);
      var localVarHeaderParameter = {};
      var localVarQueryParameter = {};
      localVarHeaderParameter['Content-Type'] = 'application/json';
      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      var needsSerialization = typeof body !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body != null ? body : {}) : body || "";
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
/**
 * TransactionServiceApi - factory function to inject configuration 
 * @export
 */
export var TransactionServiceApi = function TransactionServiceApi(configuration) {
  var fetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : portableFetch;
  var basePath = configuration && configuration.basePath || BASE_PATH;
  return {
    /**
     * 
     * @throws {RequiredError}
     */
    transactionServiceEstimateGas: function transactionServiceEstimateGas(body) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localVarFetchArgs = TransactionServiceApiFetchParamCreator(configuration).transactionServiceEstimateGas(body, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    },
    /**
     * 
     * @throws {RequiredError}
     */
    transactionServiceList: function transactionServiceList(body) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localVarFetchArgs = TransactionServiceApiFetchParamCreator(configuration).transactionServiceList(body, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    },
    /**
     * 
     * @throws {RequiredError}
     */
    transactionServiceParseTransaction: function transactionServiceParseTransaction(body) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localVarFetchArgs = TransactionServiceApiFetchParamCreator(configuration).transactionServiceParseTransaction(body, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    },
    /**
     * 
     * @throws {RequiredError}
     */
    transactionServiceSubmitTransaction: function transactionServiceSubmitTransaction(body) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localVarFetchArgs = TransactionServiceApiFetchParamCreator(configuration).transactionServiceSubmitTransaction(body, options);
      return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
        if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      });
    }
  };
};