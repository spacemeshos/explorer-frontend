// @flow
/* eslint-disable no-use-before-define */
/**
 * Spacemesh API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2alpha1
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://testnet-api.spacemesh.network".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details.  You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
 * @export
 */
export type GooglerpcStatus = {
    /**
     * The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
     * @type {number}
     * @memberof GooglerpcStatus
     */
    code?: number;
    /**
     * A list of messages that carry the error details.  There is a common set of message types for APIs to use.
     * @type {Array<ProtobufAny>}
     * @memberof GooglerpcStatus
     */
    details?: Array<ProtobufAny>;
    /**
     * A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
     * @type {string}
     * @memberof GooglerpcStatus
     */
    message?: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export type NodeStatusResponseSyncStatus = 'SYNC_STATUS_UNSPECIFIED' | 'SYNC_STATUS_OFFLINE' | 'SYNC_STATUS_SYNCING' | 'SYNC_STATUS_SYNCED';

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }     // or ...     if (any.isSameTypeAs(Foo.getDefaultInstance())) {       foo = any.unpack(Foo.getDefaultInstance());     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".  JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 */
export type ProtobufAny = {
    [key: string]: Object | any;

    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. As of May 2023, there are no widely used type server implementations and no plans to implement one.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ProtobufAny
     */
    type?: string;
}

/**
 * 
 * @export
 */
export type Spacemeshv2alpha1Account = {
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Account
     */
    address?: string;
    /**
     * 
     * @type {Spacemeshv2alpha1AccountState}
     * @memberof Spacemeshv2alpha1Account
     */
    current?: Spacemeshv2alpha1AccountState;
    /**
     * 
     * @type {Spacemeshv2alpha1AccountState}
     * @memberof Spacemeshv2alpha1Account
     */
    projected?: Spacemeshv2alpha1AccountState;
}

/**
 * 
 * @export
 */
export type Spacemeshv2alpha1AccountRequest = {
    /**
     * 
     * @type {Array<string>}
     * @memberof Spacemeshv2alpha1AccountRequest
     */
    addresses?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1AccountRequest
     */
    limit?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1AccountRequest
     */
    offset?: string;
}

/**
 * 
 * @export
 */
export type Spacemeshv2alpha1AccountState = {
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1AccountState
     */
    balance?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1AccountState
     */
    counter?: string;
    /**
     * 
     * @type {number}
     * @memberof Spacemeshv2alpha1AccountState
     */
    layer?: number;
}

/**
 * 
 * @export
 */
export type Spacemeshv2alpha1Activation = {
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Activation
     */
    coinbase?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Activation
     */
    height?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Activation
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof Spacemeshv2alpha1Activation
     */
    numUnits?: number;
    /**
     * 
     * @type {number}
     * @memberof Spacemeshv2alpha1Activation
     */
    publishEpoch?: number;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Activation
     */
    smesherId?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Activation
     */
    weight?: string;
}

/**
 * 
 * @export
 */
export type Spacemeshv2alpha1Block = {
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Block
     */
    id?: string;
}

/**
 * 
 * @export
 */
export type Spacemeshv2alpha1Layer = {
    /**
     * 
     * @type {Spacemeshv2alpha1Block}
     * @memberof Spacemeshv2alpha1Layer
     */
    block?: Spacemeshv2alpha1Block;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Layer
     */
    consensusHash?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Layer
     */
    cumulativeStateHash?: string;
    /**
     * 
     * @type {number}
     * @memberof Spacemeshv2alpha1Layer
     */
    _number?: number;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Layer
     */
    stateHash?: string;
    /**
     * 
     * @type {Spacemeshv2alpha1LayerLayerStatus}
     * @memberof Spacemeshv2alpha1Layer
     */
    status?: Spacemeshv2alpha1LayerLayerStatus;
}

/**
 * 
 * @export
 * @enum {string}
 */
export type Spacemeshv2alpha1LayerLayerStatus = 'LAYER_STATUS_UNSPECIFIED' | 'LAYER_STATUS_APPLIED' | 'LAYER_STATUS_VERIFIED';

/**
 * 
 * @export
 */
export type Spacemeshv2alpha1NetworkInfoResponse = {
    /**
     * 
     * @type {number}
     * @memberof Spacemeshv2alpha1NetworkInfoResponse
     */
    effectiveGenesisLayer?: number;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1NetworkInfoResponse
     */
    genesisId?: string;
    /**
     * 
     * @type {Date}
     * @memberof Spacemeshv2alpha1NetworkInfoResponse
     */
    genesisTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1NetworkInfoResponse
     */
    hrp?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1NetworkInfoResponse
     */
    layerDuration?: string;
    /**
     * 
     * @type {number}
     * @memberof Spacemeshv2alpha1NetworkInfoResponse
     */
    layersPerEpoch?: number;
}

/**
 * 
 * @export
 */
export type Spacemeshv2alpha1Nonce = {
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Nonce
     */
    counter?: string;
}

/**
 * 
 * @export
 */
export type Spacemeshv2alpha1ParseTransactionRequest = {
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1ParseTransactionRequest
     */
    transaction?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Spacemeshv2alpha1ParseTransactionRequest
     */
    verify?: boolean;
}

/**
 * 
 * @export
 */
export type Spacemeshv2alpha1ParseTransactionResponse = {
    /**
     * 
     * @type {GooglerpcStatus}
     * @memberof Spacemeshv2alpha1ParseTransactionResponse
     */
    status?: GooglerpcStatus;
    /**
     * 
     * @type {Spacemeshv2alpha1Transaction}
     * @memberof Spacemeshv2alpha1ParseTransactionResponse
     */
    tx?: Spacemeshv2alpha1Transaction;
}

/**
 * 
 * @export
 */
export type Spacemeshv2alpha1Reward = {
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Reward
     */
    coinbase?: string;
    /**
     * 
     * @type {number}
     * @memberof Spacemeshv2alpha1Reward
     */
    layer?: number;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Reward
     */
    layerReward?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Reward
     */
    smesher?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Reward
     */
    total?: string;
}

/**
 * 
 * @export
 */
export type Spacemeshv2alpha1SubmitTransactionRequest = {
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1SubmitTransactionRequest
     */
    transaction?: string;
}

/**
 * 
 * @export
 */
export type Spacemeshv2alpha1SubmitTransactionResponse = {
    /**
     * 
     * @type {GooglerpcStatus}
     * @memberof Spacemeshv2alpha1SubmitTransactionResponse
     */
    status?: GooglerpcStatus;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1SubmitTransactionResponse
     */
    txId?: string;
}

/**
 * An immutable Spacemesh transaction. do not include mutable data such as tx state or result.
 * @export
 */
export type Spacemeshv2alpha1Transaction = {
    /**
     * 
     * @type {V2alpha1TransactionContents}
     * @memberof Spacemeshv2alpha1Transaction
     */
    contents?: V2alpha1TransactionContents;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Transaction
     */
    gasPrice?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Transaction
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Transaction
     */
    maxGas?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Transaction
     */
    maxSpend?: string;
    /**
     * this is actually limited by uint8, but no type for that.
     * @type {number}
     * @memberof Spacemeshv2alpha1Transaction
     */
    method?: number;
    /**
     * 
     * @type {Spacemeshv2alpha1Nonce}
     * @memberof Spacemeshv2alpha1Transaction
     */
    nonce?: Spacemeshv2alpha1Nonce;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Transaction
     */
    principal?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Transaction
     */
    raw?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1Transaction
     */
    template?: string;
    /**
     * 
     * @type {TransactionTransactionType}
     * @memberof Spacemeshv2alpha1Transaction
     */
    type?: TransactionTransactionType;
}

/**
 * 
 * @export
 */
export type Spacemeshv2alpha1TransactionResult = {
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1TransactionResult
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1TransactionResult
     */
    fee?: string;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1TransactionResult
     */
    gasConsumed?: string;
    /**
     * 
     * @type {number}
     * @memberof Spacemeshv2alpha1TransactionResult
     */
    layer?: number;
    /**
     * 
     * @type {string}
     * @memberof Spacemeshv2alpha1TransactionResult
     */
    message?: string;
    /**
     * 
     * @type {Spacemeshv2alpha1TransactionResultStatus}
     * @memberof Spacemeshv2alpha1TransactionResult
     */
    status?: Spacemeshv2alpha1TransactionResultStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof Spacemeshv2alpha1TransactionResult
     */
    touchedAddresses?: Array<string>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export type Spacemeshv2alpha1TransactionResultStatus = 'TRANSACTION_STATUS_UNSPECIFIED' | 'TRANSACTION_STATUS_SUCCESS' | 'TRANSACTION_STATUS_FAILURE' | 'TRANSACTION_STATUS_INVALID';

/**
 * TransactionState is the \"journey\" of a tx from mempool to block inclusion to mesh to STF processing. To know whether or not the tx actually succeeded, and its side effects, check tx_state.   - TRANSACTION_STATE_UNSPECIFIED: default state  - TRANSACTION_STATE_REJECTED: rejected from mempool due to, e.g., invalid syntax  - TRANSACTION_STATE_INSUFFICIENT_FUNDS: rejected from mempool by funds check  - TRANSACTION_STATE_CONFLICTING: rejected from mempool due to conflicting counter  - TRANSACTION_STATE_MEMPOOL: in mempool but not on the mesh yet  - TRANSACTION_STATE_MESH: submitted to the mesh  - TRANSACTION_STATE_PROCESSED: processed by STF; check Receipt for success or failure
 * @export
 * @enum {string}
 */
export type Spacemeshv2alpha1TransactionState = 'TRANSACTION_STATE_UNSPECIFIED' | 'TRANSACTION_STATE_REJECTED' | 'TRANSACTION_STATE_INSUFFICIENT_FUNDS' | 'TRANSACTION_STATE_CONFLICTING' | 'TRANSACTION_STATE_MEMPOOL' | 'TRANSACTION_STATE_MESH' | 'TRANSACTION_STATE_PROCESSED';

/**
 * 
 * @export
 * @enum {string}
 */
export type TransactionTransactionType = 'TRANSACTION_TYPE_UNSPECIFIED' | 'TRANSACTION_TYPE_SINGLE_SIG_SEND' | 'TRANSACTION_TYPE_SINGLE_SIG_SPAWN' | 'TRANSACTION_TYPE_SINGLE_SIG_SELFSPAWN' | 'TRANSACTION_TYPE_MULTI_SIG_SEND' | 'TRANSACTION_TYPE_MULTI_SIG_SPAWN' | 'TRANSACTION_TYPE_MULTI_SIG_SELFSPAWN' | 'TRANSACTION_TYPE_VESTING_SPAWN' | 'TRANSACTION_TYPE_VAULT_SPAWN' | 'TRANSACTION_TYPE_DRAIN_VAULT';

/**
 * 
 * @export
 */
export type V2alpha1AccountList = {
    /**
     * 
     * @type {Array<Spacemeshv2alpha1Account>}
     * @memberof V2alpha1AccountList
     */
    accounts?: Array<Spacemeshv2alpha1Account>;
}

/**
 * 
 * @export
 */
export type V2alpha1ActivationList = {
    /**
     * 
     * @type {Array<Spacemeshv2alpha1Activation>}
     * @memberof V2alpha1ActivationList
     */
    activations?: Array<Spacemeshv2alpha1Activation>;
}

/**
 * 
 * @export
 */
export type V2alpha1ActivationRequest = {
    /**
     * `coinbase` filter is not supported by database index and will result in sequential scan.
     * @type {string}
     * @memberof V2alpha1ActivationRequest
     */
    coinbase?: string;
    /**
     * 
     * @type {number}
     * @memberof V2alpha1ActivationRequest
     */
    endEpoch?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof V2alpha1ActivationRequest
     */
    id?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V2alpha1ActivationRequest
     */
    limit?: string;
    /**
     * 
     * @type {string}
     * @memberof V2alpha1ActivationRequest
     */
    offset?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V2alpha1ActivationRequest
     */
    smesherId?: Array<string>;
    /**
     * Apply `start_epoch/end_epoch` filters together with `coinbase` filter for better performance.
     * @type {number}
     * @memberof V2alpha1ActivationRequest
     */
    startEpoch?: number;
}

/**
 * 
 * @export
 */
export type V2alpha1ActivationsCountRequest = {
    /**
     * 
     * @type {number}
     * @memberof V2alpha1ActivationsCountRequest
     */
    epoch?: number;
}

/**
 * 
 * @export
 */
export type V2alpha1ActivationsCountResponse = {
    /**
     * 
     * @type {number}
     * @memberof V2alpha1ActivationsCountResponse
     */
    count?: number;
}

/**
 * 
 * @export
 */
export type V2alpha1ContentsDrainVault = {
    /**
     * 
     * @type {string}
     * @memberof V2alpha1ContentsDrainVault
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof V2alpha1ContentsDrainVault
     */
    destination?: string;
    /**
     * 
     * @type {string}
     * @memberof V2alpha1ContentsDrainVault
     */
    vault?: string;
}

/**
 * 
 * @export
 */
export type V2alpha1ContentsMultiSigSpawn = {
    /**
     * 
     * @type {Array<string>}
     * @memberof V2alpha1ContentsMultiSigSpawn
     */
    pubkey?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof V2alpha1ContentsMultiSigSpawn
     */
    required?: number;
}

/**
 * 
 * @export
 */
export type V2alpha1ContentsSend = {
    /**
     * 
     * @type {string}
     * @memberof V2alpha1ContentsSend
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof V2alpha1ContentsSend
     */
    destination?: string;
}

/**
 * 
 * @export
 */
export type V2alpha1ContentsSingleSigSpawn = {
    /**
     * 
     * @type {string}
     * @memberof V2alpha1ContentsSingleSigSpawn
     */
    pubkey?: string;
}

/**
 * 
 * @export
 */
export type V2alpha1ContentsVaultSpawn = {
    /**
     * 
     * @type {string}
     * @memberof V2alpha1ContentsVaultSpawn
     */
    initialUnlockAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof V2alpha1ContentsVaultSpawn
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V2alpha1ContentsVaultSpawn
     */
    totalAmount?: string;
    /**
     * 
     * @type {number}
     * @memberof V2alpha1ContentsVaultSpawn
     */
    vestingEnd?: number;
    /**
     * 
     * @type {number}
     * @memberof V2alpha1ContentsVaultSpawn
     */
    vestingStart?: number;
}

/**
 * 
 * @export
 */
export type V2alpha1EstimateGasRequest = {
    /**
     * 
     * @type {string}
     * @memberof V2alpha1EstimateGasRequest
     */
    transaction?: string;
}

/**
 * 
 * @export
 */
export type V2alpha1EstimateGasResponse = {
    /**
     * 
     * @type {string}
     * @memberof V2alpha1EstimateGasResponse
     */
    recommendedMaxGas?: string;
    /**
     * 
     * @type {GooglerpcStatus}
     * @memberof V2alpha1EstimateGasResponse
     */
    status?: GooglerpcStatus;
}

/**
 * 
 * @export
 */
export type V2alpha1LayerList = {
    /**
     * 
     * @type {Array<Spacemeshv2alpha1Layer>}
     * @memberof V2alpha1LayerList
     */
    layers?: Array<Spacemeshv2alpha1Layer>;
}

/**
 * 
 * @export
 */
export type V2alpha1LayerRequest = {
    /**
     * 
     * @type {number}
     * @memberof V2alpha1LayerRequest
     */
    endLayer?: number;
    /**
     * 
     * @type {string}
     * @memberof V2alpha1LayerRequest
     */
    limit?: string;
    /**
     * 
     * @type {string}
     * @memberof V2alpha1LayerRequest
     */
    offset?: string;
    /**
     * 
     * @type {V2alpha1SortOrder}
     * @memberof V2alpha1LayerRequest
     */
    sortOrder?: V2alpha1SortOrder;
    /**
     * 
     * @type {number}
     * @memberof V2alpha1LayerRequest
     */
    startLayer?: number;
}

/**
 * 
 * @export
 */
export type V2alpha1NodeStatusResponse = {
    /**
     * 
     * @type {number}
     * @memberof V2alpha1NodeStatusResponse
     */
    appliedLayer?: number;
    /**
     * 
     * @type {string}
     * @memberof V2alpha1NodeStatusResponse
     */
    connectedPeers?: string;
    /**
     * 
     * @type {number}
     * @memberof V2alpha1NodeStatusResponse
     */
    currentLayer?: number;
    /**
     * 
     * @type {number}
     * @memberof V2alpha1NodeStatusResponse
     */
    latestLayer?: number;
    /**
     * 
     * @type {number}
     * @memberof V2alpha1NodeStatusResponse
     */
    processedLayer?: number;
    /**
     * 
     * @type {NodeStatusResponseSyncStatus}
     * @memberof V2alpha1NodeStatusResponse
     */
    status?: NodeStatusResponseSyncStatus;
}

/**
 * 
 * @export
 */
export type V2alpha1RewardList = {
    /**
     * 
     * @type {Array<Spacemeshv2alpha1Reward>}
     * @memberof V2alpha1RewardList
     */
    rewards?: Array<Spacemeshv2alpha1Reward>;
}

/**
 * 
 * @export
 */
export type V2alpha1RewardRequest = {
    /**
     * 
     * @type {string}
     * @memberof V2alpha1RewardRequest
     */
    coinbase?: string;
    /**
     * 
     * @type {number}
     * @memberof V2alpha1RewardRequest
     */
    endLayer?: number;
    /**
     * 
     * @type {string}
     * @memberof V2alpha1RewardRequest
     */
    limit?: string;
    /**
     * 
     * @type {string}
     * @memberof V2alpha1RewardRequest
     */
    offset?: string;
    /**
     * 
     * @type {string}
     * @memberof V2alpha1RewardRequest
     */
    smesher?: string;
    /**
     * 
     * @type {V2alpha1SortOrder}
     * @memberof V2alpha1RewardRequest
     */
    sortOrder?: V2alpha1SortOrder;
    /**
     * 
     * @type {number}
     * @memberof V2alpha1RewardRequest
     */
    startLayer?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export type V2alpha1SortOrder = 'ASC' | 'DESC';

/**
 * 
 * @export
 */
export type V2alpha1TransactionContents = {
    /**
     * 
     * @type {V2alpha1ContentsDrainVault}
     * @memberof V2alpha1TransactionContents
     */
    drainVault?: V2alpha1ContentsDrainVault;
    /**
     * 
     * @type {V2alpha1ContentsMultiSigSpawn}
     * @memberof V2alpha1TransactionContents
     */
    multiSigSpawn?: V2alpha1ContentsMultiSigSpawn;
    /**
     * 
     * @type {V2alpha1ContentsSend}
     * @memberof V2alpha1TransactionContents
     */
    send?: V2alpha1ContentsSend;
    /**
     * 
     * @type {V2alpha1ContentsSingleSigSpawn}
     * @memberof V2alpha1TransactionContents
     */
    singleSigSpawn?: V2alpha1ContentsSingleSigSpawn;
    /**
     * 
     * @type {V2alpha1ContentsVaultSpawn}
     * @memberof V2alpha1TransactionContents
     */
    vaultSpawn?: V2alpha1ContentsVaultSpawn;
    /**
     * 
     * @type {V2alpha1ContentsMultiSigSpawn}
     * @memberof V2alpha1TransactionContents
     */
    vestingSpawn?: V2alpha1ContentsMultiSigSpawn;
}

/**
 * 
 * @export
 */
export type V2alpha1TransactionList = {
    /**
     * 
     * @type {Array<V2alpha1TransactionResponse>}
     * @memberof V2alpha1TransactionList
     */
    transactions?: Array<V2alpha1TransactionResponse>;
}

/**
 * 
 * @export
 */
export type V2alpha1TransactionRequest = {
    /**
     * 
     * @type {string}
     * @memberof V2alpha1TransactionRequest
     */
    address?: string;
    /**
     * Ending layer for transactions.
     * @type {number}
     * @memberof V2alpha1TransactionRequest
     */
    endLayer?: number;
    /**
     * Whether to include result of transactions in response.
     * @type {boolean}
     * @memberof V2alpha1TransactionRequest
     */
    includeResult?: boolean;
    /**
     * Whether to include transaction state in response.
     * @type {boolean}
     * @memberof V2alpha1TransactionRequest
     */
    includeState?: boolean;
    /**
     * Specifies maximum number of items to fetch.
     * @type {string}
     * @memberof V2alpha1TransactionRequest
     */
    limit?: string;
    /**
     * Adjusts the starting point for data retrieval.
     * @type {string}
     * @memberof V2alpha1TransactionRequest
     */
    offset?: string;
    /**
     * 
     * @type {V2alpha1SortOrder}
     * @memberof V2alpha1TransactionRequest
     */
    sortOrder?: V2alpha1SortOrder;
    /**
     * Starting layer for transactions.
     * @type {number}
     * @memberof V2alpha1TransactionRequest
     */
    startLayer?: number;
    /**
     * Filter: specific transaction IDs to filter.
     * @type {Array<string>}
     * @memberof V2alpha1TransactionRequest
     */
    txid?: Array<string>;
}

/**
 * 
 * @export
 */
export type V2alpha1TransactionResponse = {
    /**
     * 
     * @type {Spacemeshv2alpha1Transaction}
     * @memberof V2alpha1TransactionResponse
     */
    tx?: Spacemeshv2alpha1Transaction;
    /**
     * 
     * @type {Spacemeshv2alpha1TransactionResult}
     * @memberof V2alpha1TransactionResponse
     */
    txResult?: Spacemeshv2alpha1TransactionResult;
    /**
     * 
     * @type {Spacemeshv2alpha1TransactionState}
     * @memberof V2alpha1TransactionResponse
     */
    txState?: Spacemeshv2alpha1TransactionState;
}



/**
 * AccountServiceApi - fetch parameter creator
 * @export
 */
export const AccountServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        accountServiceList(body: Spacemeshv2alpha1AccountRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accountServiceList.');
            }
            const localVarPath = `/spacemesh.v2alpha1.AccountService/List`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body != null ? body : {}) : (((body:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type AccountServiceApiType = { 
    accountServiceList(body: Spacemeshv2alpha1AccountRequest, options?: RequestOptions): Promise<V2alpha1AccountList>,
}

/**
 * AccountServiceApi - factory function to inject configuration 
 * @export
 */
export const AccountServiceApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): AccountServiceApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        accountServiceList(body: Spacemeshv2alpha1AccountRequest, options?: RequestOptions = {}): Promise<V2alpha1AccountList> {
            const localVarFetchArgs = AccountServiceApiFetchParamCreator(configuration).accountServiceList(body, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ActivationServiceApi - fetch parameter creator
 * @export
 */
export const ActivationServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        activationServiceActivationsCount(body: V2alpha1ActivationsCountRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling activationServiceActivationsCount.');
            }
            const localVarPath = `/spacemesh.v2alpha1.ActivationService/ActivationsCount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body != null ? body : {}) : (((body:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        activationServiceList(body: V2alpha1ActivationRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling activationServiceList.');
            }
            const localVarPath = `/spacemesh.v2alpha1.ActivationService/List`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body != null ? body : {}) : (((body:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ActivationServiceApiType = { 
    activationServiceActivationsCount(body: V2alpha1ActivationsCountRequest, options?: RequestOptions): Promise<V2alpha1ActivationsCountResponse>,

    activationServiceList(body: V2alpha1ActivationRequest, options?: RequestOptions): Promise<V2alpha1ActivationList>,
}

/**
 * ActivationServiceApi - factory function to inject configuration 
 * @export
 */
export const ActivationServiceApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ActivationServiceApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        activationServiceActivationsCount(body: V2alpha1ActivationsCountRequest, options?: RequestOptions = {}): Promise<V2alpha1ActivationsCountResponse> {
            const localVarFetchArgs = ActivationServiceApiFetchParamCreator(configuration).activationServiceActivationsCount(body, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        activationServiceList(body: V2alpha1ActivationRequest, options?: RequestOptions = {}): Promise<V2alpha1ActivationList> {
            const localVarFetchArgs = ActivationServiceApiFetchParamCreator(configuration).activationServiceList(body, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * LayerServiceApi - fetch parameter creator
 * @export
 */
export const LayerServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        layerServiceList(body: V2alpha1LayerRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling layerServiceList.');
            }
            const localVarPath = `/spacemesh.v2alpha1.LayerService/List`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body != null ? body : {}) : (((body:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type LayerServiceApiType = { 
    layerServiceList(body: V2alpha1LayerRequest, options?: RequestOptions): Promise<V2alpha1LayerList>,
}

/**
 * LayerServiceApi - factory function to inject configuration 
 * @export
 */
export const LayerServiceApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): LayerServiceApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        layerServiceList(body: V2alpha1LayerRequest, options?: RequestOptions = {}): Promise<V2alpha1LayerList> {
            const localVarFetchArgs = LayerServiceApiFetchParamCreator(configuration).layerServiceList(body, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * NetworkServiceApi - fetch parameter creator
 * @export
 */
export const NetworkServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        networkServiceInfo(body: Object, options: RequestOptions): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling networkServiceInfo.');
            }
            const localVarPath = `/spacemesh.v2alpha1.NetworkService/Info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body != null ? body : {}) : (((body:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type NetworkServiceApiType = { 
    networkServiceInfo(body: Object, options?: RequestOptions): Promise<Spacemeshv2alpha1NetworkInfoResponse>,
}

/**
 * NetworkServiceApi - factory function to inject configuration 
 * @export
 */
export const NetworkServiceApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): NetworkServiceApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        networkServiceInfo(body: Object, options?: RequestOptions = {}): Promise<Spacemeshv2alpha1NetworkInfoResponse> {
            const localVarFetchArgs = NetworkServiceApiFetchParamCreator(configuration).networkServiceInfo(body, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * NodeServiceApi - fetch parameter creator
 * @export
 */
export const NodeServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        nodeServiceStatus(body: Object, options: RequestOptions): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling nodeServiceStatus.');
            }
            const localVarPath = `/spacemesh.v2alpha1.NodeService/Status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body != null ? body : {}) : (((body:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type NodeServiceApiType = { 
    nodeServiceStatus(body: Object, options?: RequestOptions): Promise<V2alpha1NodeStatusResponse>,
}

/**
 * NodeServiceApi - factory function to inject configuration 
 * @export
 */
export const NodeServiceApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): NodeServiceApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        nodeServiceStatus(body: Object, options?: RequestOptions = {}): Promise<V2alpha1NodeStatusResponse> {
            const localVarFetchArgs = NodeServiceApiFetchParamCreator(configuration).nodeServiceStatus(body, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * RewardServiceApi - fetch parameter creator
 * @export
 */
export const RewardServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        rewardServiceList(body: V2alpha1RewardRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rewardServiceList.');
            }
            const localVarPath = `/spacemesh.v2alpha1.RewardService/List`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body != null ? body : {}) : (((body:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type RewardServiceApiType = { 
    rewardServiceList(body: V2alpha1RewardRequest, options?: RequestOptions): Promise<V2alpha1RewardList>,
}

/**
 * RewardServiceApi - factory function to inject configuration 
 * @export
 */
export const RewardServiceApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): RewardServiceApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        rewardServiceList(body: V2alpha1RewardRequest, options?: RequestOptions = {}): Promise<V2alpha1RewardList> {
            const localVarFetchArgs = RewardServiceApiFetchParamCreator(configuration).rewardServiceList(body, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * TransactionServiceApi - fetch parameter creator
 * @export
 */
export const TransactionServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        transactionServiceEstimateGas(body: V2alpha1EstimateGasRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling transactionServiceEstimateGas.');
            }
            const localVarPath = `/spacemesh.v2alpha1.TransactionService/EstimateGas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body != null ? body : {}) : (((body:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        transactionServiceList(body: V2alpha1TransactionRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling transactionServiceList.');
            }
            const localVarPath = `/spacemesh.v2alpha1.TransactionService/List`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body != null ? body : {}) : (((body:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        transactionServiceParseTransaction(body: Spacemeshv2alpha1ParseTransactionRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling transactionServiceParseTransaction.');
            }
            const localVarPath = `/spacemesh.v2alpha1.TransactionService/ParseTransaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body != null ? body : {}) : (((body:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @throws {RequiredError}
         */
        transactionServiceSubmitTransaction(body: Spacemeshv2alpha1SubmitTransactionRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling transactionServiceSubmitTransaction.');
            }
            const localVarPath = `/spacemesh.v2alpha1.TransactionService/SubmitTransaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body != null ? body : {}) : (((body:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TransactionServiceApiType = { 
    transactionServiceEstimateGas(body: V2alpha1EstimateGasRequest, options?: RequestOptions): Promise<V2alpha1EstimateGasResponse>,

    transactionServiceList(body: V2alpha1TransactionRequest, options?: RequestOptions): Promise<V2alpha1TransactionList>,

    transactionServiceParseTransaction(body: Spacemeshv2alpha1ParseTransactionRequest, options?: RequestOptions): Promise<Spacemeshv2alpha1ParseTransactionResponse>,

    transactionServiceSubmitTransaction(body: Spacemeshv2alpha1SubmitTransactionRequest, options?: RequestOptions): Promise<Spacemeshv2alpha1SubmitTransactionResponse>,
}

/**
 * TransactionServiceApi - factory function to inject configuration 
 * @export
 */
export const TransactionServiceApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TransactionServiceApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @throws {RequiredError}
         */
        transactionServiceEstimateGas(body: V2alpha1EstimateGasRequest, options?: RequestOptions = {}): Promise<V2alpha1EstimateGasResponse> {
            const localVarFetchArgs = TransactionServiceApiFetchParamCreator(configuration).transactionServiceEstimateGas(body, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        transactionServiceList(body: V2alpha1TransactionRequest, options?: RequestOptions = {}): Promise<V2alpha1TransactionList> {
            const localVarFetchArgs = TransactionServiceApiFetchParamCreator(configuration).transactionServiceList(body, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        transactionServiceParseTransaction(body: Spacemeshv2alpha1ParseTransactionRequest, options?: RequestOptions = {}): Promise<Spacemeshv2alpha1ParseTransactionResponse> {
            const localVarFetchArgs = TransactionServiceApiFetchParamCreator(configuration).transactionServiceParseTransaction(body, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @throws {RequiredError}
         */
        transactionServiceSubmitTransaction(body: Spacemeshv2alpha1SubmitTransactionRequest, options?: RequestOptions = {}): Promise<Spacemeshv2alpha1SubmitTransactionResponse> {
            const localVarFetchArgs = TransactionServiceApiFetchParamCreator(configuration).transactionServiceSubmitTransaction(body, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    AccountServiceApi: AccountServiceApiType,

    ActivationServiceApi: ActivationServiceApiType,

    LayerServiceApi: LayerServiceApiType,

    NetworkServiceApi: NetworkServiceApiType,

    NodeServiceApi: NodeServiceApiType,

    RewardServiceApi: RewardServiceApiType,

    TransactionServiceApi: TransactionServiceApiType,
 }
